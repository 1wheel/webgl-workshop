{
  "name": "@exercise/buffer-elements",
  "version": "1.0.0",
  "main": "server.js",
  "dependencies": {},
  "scripts": {
    "start": "node server.js"
  },
  "readme": "# Exercise\n\nFor this exercise you will draw a mesh using indexed arrays.  A shader with the necessary vertex attributes is provided for you.  It is up to you to set up the element array buffer and draw the object with the correct.\n\nThe contents of the element array buffer are provided for you in a native array called `ELEMENT_DATA` and the number of elements to draw is stored in the variable `ELEMENT_COUNT`.\n\n# Element Array Buffers\n\nDrawing too many vertices in WebGL can become expensive.  This is because each vertex consumes some fixed amount of memory and must be processed by a vertex shader.  To optimize rendering, it is therefore useful to reduce the number of vertices which are sent to the GPU.\n\nOne way to do this is with *indexed drawing*. In indexed drawing, send two pieces of data to WebGL:\n\n* A buffer full of vertex attributes\n* A second buffer full of pointers to vertices\n\nThe primitives are then drawn using the indices from the second array.  The advantage to doing things this way is that it allows us to reuse the same vertex in multiple primitives.\n\nThese buffers of pointers are called *element array buffers* and are created in almost the same way as normal array buffers.  For example suppose that we wanted to create an element array buffer with the following array of vertex indices:\n\n```javascript\nvar indices = [\n  0, 1, 2,   // First triangle\n  3, 4, 5,   // Second triangle\n  0, 2, 4    // Third triangle\n]\n```\n\nThen we can initialize an element array buffer with these indices as follows:\n\n```javascript\nvar elementBuffer = gl.createBuffer(gl.ELEMENT_ARRAY_BUFFER)\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer)\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER,\n  new Uint16Array(indices),\n  gl.STATIC_DRAW)\n```\n\nThere are two important things which are different here from before:\n\n* Instead of using `gl.ARRAY_BUFFER`, we use `gl.ELEMENT_ARRAY_BUFFER`\n* Input data to an element array buffer **MUST** be in a `Uint16Array`\n\nThis last point is a default technical restriction in WebGL, though there are some extensions which can change this behavior.\n\nOnce we have an element array buffer set up, we can use it to draw things by calling the `gl.drawElements` command.  For example:\n\n```javascript\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer)\ngl.drawElements(gl.TRIANGLES, 9, gl.UNSIGNED_SHORT, 0)\n```\n\nThe arguments to this command are as follows:\n\n## `gl.drawElements(type, count, gl.UNSIGNED_SHORT, offset)`\nThe behavior here is almost exactly the same as `gl.drawArrays` except:\n\n* The order of `count` and `offset` is switched in the arguments\n* There is this extra `gl.UNSIGNED_SHORT` argument which you must pass in (no other values are allowed)\n* Primitives are drawn using indices from the element array buffer instead of reading directly from the current array buffer\n",
  "readmeFilename": "README.md",
  "description": "For this exercise you will draw a mesh using indexed arrays.  A shader with the necessary vertex attributes is provided for you.  It is up to you to set up the element array buffer and draw the object with the correct.",
  "_id": "@exercise/buffer-elements@1.0.0",
  "_shasum": "9f8f0d3932642d18f40338d6d8c234cb6797bc61",
  "_from": "exercises/buffer-elements",
  "_resolved": "file:exercises/buffer-elements"
}
